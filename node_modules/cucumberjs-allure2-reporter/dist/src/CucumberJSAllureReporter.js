"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
var cucumber_1 = require("cucumber");
var allure2_js_commons_1 = require("allure2-js-commons");
var SourceLocation_1 = require("./events/SourceLocation");
var Example_1 = require("./events/Example");
var CucumberAllureInterface_1 = require("./CucumberAllureInterface");
var utilities_1 = require("./utilities");
var allure2_js_commons_2 = require("allure2-js-commons");
exports.AllureInterface = allure2_js_commons_2.AllureInterface;
var CucumberJSAllureFormatterConfig = /** @class */ (function () {
    function CucumberJSAllureFormatterConfig() {
    }
    return CucumberJSAllureFormatterConfig;
}());
exports.CucumberJSAllureFormatterConfig = CucumberJSAllureFormatterConfig;
var CucumberJSAllureFormatter = /** @class */ (function (_super) {
    __extends(CucumberJSAllureFormatter, _super);
    function CucumberJSAllureFormatter(options, allureRuntime, config) {
        var _this = _super.call(this, options) || this;
        _this.allureRuntime = allureRuntime;
        _this.sourceMap = new Map();
        _this.stepsMap = new Map();
        _this.featureMap = new Map();
        _this.stepStack = [];
        _this.currentGroup = null;
        _this.currentTest = null;
        _this.currentBefore = null;
        _this.currentAfter = null;
        options.eventBroadcaster
            .on("source", _this.onSource.bind(_this))
            .on("gherkin-document", _this.onGherkinDocument.bind(_this))
            .on("test-case-prepared", _this.onTestCasePrepared.bind(_this))
            .on("test-case-started", _this.onTestCaseStarted.bind(_this))
            .on("test-step-started", _this.onTestStepStarted.bind(_this))
            .on("test-step-attachment", _this.onTestStepAttachment.bind(_this))
            .on("test-step-finished", _this.onTestStepFinished.bind(_this))
            .on("test-case-finished", _this.onTestCaseFinished.bind(_this));
        _this.labels = config.labels || {};
        _this.exceptionFormatter = function (message) {
            if (config.exceptionFormatter !== undefined) {
                try {
                    return config.exceptionFormatter(message);
                }
                catch (e) {
                    console.warn("Error in exceptionFormatter: " + e);
                }
            }
            return message;
        };
        _this.allureInterface = new CucumberAllureInterface_1.CucumberAllureInterface(_this);
        options.supportCodeLibrary.World.prototype.allure = _this.allureInterface;
        _this.beforeHooks = options.supportCodeLibrary.beforeTestCaseHookDefinitions;
        _this.afterHooks = options.supportCodeLibrary.afterTestCaseHookDefinitions;
        return _this;
    }
    CucumberJSAllureFormatter.prototype.onSource = function (data) {
        this.sourceMap.set(data.uri, data.data.split(/\n/));
    };
    CucumberJSAllureFormatter.prototype.onGherkinDocument = function (data) {
        // "ScenarioOutline"
        data.document.caseMap = new Map();
        data.document.stepMap = new Map();
        if (data.document.feature !== undefined) {
            for (var _i = 0, _a = data.document.feature.children || []; _i < _a.length; _i++) {
                var test = _a[_i];
                test.stepMap = new Map();
                if (test.type === "Background") {
                    data.document.stepMap = new Map();
                    for (var _b = 0, _c = test.steps; _b < _c.length; _b++) {
                        var step = _c[_b];
                        step.isBackground = true;
                        data.document.stepMap.set(step.location.line, step);
                    }
                }
                else {
                    for (var _d = 0, _e = test.steps; _d < _e.length; _d++) {
                        var step = _e[_d];
                        test.stepMap.set(step.location.line, step);
                    }
                }
                if (test.type === "ScenarioOutline") {
                    for (var _f = 0, _g = Example_1.examplesToSensibleFormat(test.examples || []); _f < _g.length; _f++) {
                        var example = _g[_f];
                        var copy = __assign({}, test);
                        copy.example = example;
                        data.document.caseMap.set(example.line, copy);
                    }
                }
                else {
                    data.document.caseMap.set(test.location.line, test);
                }
            }
        }
        this.featureMap.set(data.uri, data.document);
    };
    CucumberJSAllureFormatter.prototype.onTestCasePrepared = function (data) {
        this.stepsMap.clear();
        this.stepsMap.set(SourceLocation_1.SourceLocation.toKey(data), data.steps);
        this.currentBefore = null;
        this.currentAfter = null;
    };
    CucumberJSAllureFormatter.prototype.onTestCaseStarted = function (data) {
        var feature = this.featureMap.get(data.sourceLocation.uri);
        if (feature === undefined || feature.feature === undefined)
            throw new Error("Unknown feature");
        var test = feature.caseMap === undefined ? undefined : feature.caseMap.get(data.sourceLocation.line);
        if (test === undefined)
            throw new Error("Unknown scenario");
        this.currentGroup = this.allureRuntime.startGroup("");
        this.currentTest = this.currentGroup.startTest(utilities_1.applyExample(test.name || "Unnamed test", test.example));
        var info = {
            f: feature.feature.name,
            t: test.name,
            a: null
        };
        if (test.example !== undefined) {
            info.a = test.example.arguments;
            for (var prop in test.example.arguments) {
                if (!test.example.arguments.hasOwnProperty(prop))
                    continue;
                this.currentTest.addParameter(prop, test.example.arguments[prop]);
            }
        }
        this.currentTest.historyId = utilities_1.hash(JSON.stringify(info));
        this.currentTest.addLabel(allure2_js_commons_1.LabelName.THREAD, "" + process.pid); // parallel tests support
        this.currentTest.addLabel(allure2_js_commons_1.LabelName.FEATURE, feature.feature.name);
        //this.currentTest.addLabel(LabelName.STORY, feature.feature.name);
        this.currentTest.description = utilities_1.stripIndent(test.description || "");
        for (var _i = 0, _a = (test.tags || []).concat(feature.feature.tags); _i < _a.length; _i++) {
            var tag = _a[_i];
            this.currentTest.addLabel(allure2_js_commons_1.LabelName.TAG, tag.name);
            for (var label in this.labels) {
                if (!this.labels.hasOwnProperty(label))
                    continue;
                for (var _b = 0, _c = this.labels[label]; _b < _c.length; _b++) {
                    var reg = _c[_b];
                    var match = tag.name.match(reg);
                    if (match != null && match.length > 1) {
                        this.currentTest.addLabel(label, match[1]);
                    }
                }
            }
        }
    };
    CucumberJSAllureFormatter.prototype.onTestStepStarted = function (data) {
        var location = (this.stepsMap.get(SourceLocation_1.SourceLocation.toKey(data.testCase)) || [])[data.index];
        var feature = this.featureMap.get(data.testCase.sourceLocation.uri);
        if (feature === undefined)
            throw new Error("Unknown feature");
        var test = feature.caseMap === undefined ? undefined : feature.caseMap.get(data.testCase.sourceLocation.line);
        if (test === undefined)
            throw new Error("Unknown scenario");
        var step;
        if (location.sourceLocation !== undefined && feature.stepMap !== undefined) {
            step = test.stepMap.get(location.sourceLocation.line) || feature.stepMap.get(location.sourceLocation.line);
        }
        else {
            if (location.actionLocation === undefined)
                location.actionLocation = { uri: "unknown", line: -1 };
            step = {
                location: { line: -1 },
                text: location.actionLocation.uri + ":" + location.actionLocation.line,
                keyword: ""
            };
        }
        if (step === undefined)
            throw new Error("Unknown step");
        var stepText = utilities_1.applyExample("" + step.keyword + step.text, test.example);
        var isAfter = this.afterHooks.find(function (_a) {
            var uri = _a.uri, line = _a.line;
            if (location.actionLocation === undefined)
                return false;
            return uri === location.actionLocation.uri &&
                line === location.actionLocation.line;
        });
        var isBefore = this.beforeHooks.find(function (_a) {
            var uri = _a.uri, line = _a.line;
            if (location.actionLocation === undefined)
                return false;
            return uri === location.actionLocation.uri &&
                line === location.actionLocation.line;
        });
        if (step.isBackground) {
            if (this.currentBefore === null)
                this.currentBefore = this.currentGroup.addBefore();
        }
        else if (isBefore) {
            if (this.currentBefore === null)
                this.currentBefore = this.currentGroup.addBefore();
            stepText = "Before: " + (isBefore.code.name || step.text);
        }
        else if (isAfter) {
            if (this.currentAfter === null)
                this.currentAfter = this.currentGroup.addAfter();
            stepText = "After: " + (isAfter.code.name || step.text);
        }
        else {
            if (this.currentBefore !== null)
                this.currentBefore = null;
            if (this.currentAfter !== null)
                this.currentAfter = null;
        }
        var allureStep = (this.currentAfter || this.currentBefore || this.currentTest).startStep(stepText);
        this.pushStep(allureStep);
        if (step.argument !== undefined) {
            if (step.argument.content !== undefined) {
                var file = this.allureRuntime.writeAttachment(step.argument.content, allure2_js_commons_1.ContentType.TEXT);
                allureStep.addAttachment("Text", allure2_js_commons_1.ContentType.TEXT, file);
            }
            if (step.argument.rows !== undefined) {
                var file = this.allureRuntime.writeAttachment(step.argument.rows.map(function (row) { return row.cells.map(function (cell) { return cell.value.replace(/\t/g, "    "); }).join("\t"); }).join("\n"), allure2_js_commons_1.ContentType.TSV);
                allureStep.addAttachment("Table", allure2_js_commons_1.ContentType.TSV, file);
            }
        }
    };
    CucumberJSAllureFormatter.prototype.onTestStepAttachment = function (data) {
        if (this.currentStep === null)
            throw new Error("There is no step to add attachment to");
        var type = data.media.type;
        var content = data.data;
        if ([allure2_js_commons_1.ContentType.JPEG, allure2_js_commons_1.ContentType.PNG, allure2_js_commons_1.ContentType.WEBM].indexOf(type) >= 0)
            content = Buffer.from(content, "base64");
        var file = this.allureRuntime.writeAttachment(content, type);
        this.currentStep.addAttachment("attached", type, file);
    };
    CucumberJSAllureFormatter.prototype.onTestStepFinished = function (data) {
        var currentStep = this.currentStep; // eslint-disable-line prefer-destructuring
        if (currentStep === null)
            throw new Error("No current step defined");
        currentStep.status = utilities_1.statusTextToAllure(data.result.status);
        currentStep.stage = utilities_1.statusTextToStage(data.result.status);
        this.setException(currentStep, data.result.exception);
        currentStep.endStep();
        this.popStep();
    };
    CucumberJSAllureFormatter.prototype.onTestCaseFinished = function (data) {
        if (this.currentTest === null || this.currentGroup === null)
            throw new Error("No current test info");
        this.currentTest.status = utilities_1.statusTextToAllure(data.result.status);
        this.currentTest.stage = utilities_1.statusTextToStage(data.result.status);
        this.setException(this.currentTest, data.result.exception);
        this.currentTest.endTest();
        this.currentGroup.endGroup();
    };
    CucumberJSAllureFormatter.prototype.setException = function (target, exception) {
        if (exception !== undefined) {
            if (typeof exception === "string") {
                target.detailsMessage = this.exceptionFormatter(exception);
            }
            else {
                target.detailsMessage = this.exceptionFormatter(exception.message || "Error.message === undefined");
                target.detailsTrace = exception.stack || "";
            }
        }
    };
    CucumberJSAllureFormatter.prototype.pushStep = function (step) {
        this.stepStack.push(step);
    };
    CucumberJSAllureFormatter.prototype.popStep = function () {
        this.stepStack.pop();
    };
    Object.defineProperty(CucumberJSAllureFormatter.prototype, "currentStep", {
        get: function () {
            if (this.stepStack.length > 0)
                return this.stepStack[this.stepStack.length - 1];
            return null;
        },
        enumerable: true,
        configurable: true
    });
    CucumberJSAllureFormatter.prototype.writeAttachment = function (content, type) {
        return this.allureRuntime.writeAttachment(content, type);
    };
    CucumberJSAllureFormatter.prototype.getGlobalInfoWriter = function () {
        return this.allureRuntime;
    };
    return CucumberJSAllureFormatter;
}(cucumber_1.Formatter));
exports.CucumberJSAllureFormatter = CucumberJSAllureFormatter;
//# sourceMappingURL=CucumberJSAllureReporter.js.map