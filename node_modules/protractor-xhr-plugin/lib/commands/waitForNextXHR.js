'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.waitForNextXHR = waitForNextXHR;

var _util = require('util');

var _util2 = _interopRequireDefault(_util);

var _events = require('events');

var _events2 = _interopRequireDefault(_events);

var _client = require('../client');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function waitForNextXHRWithCB() {
    var urlPattern = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
    var delay = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1000;
    var callback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function () {};

    var api = browser;

    // console.log('Verifying request ...');
    if (typeof urlPattern === 'string') {
        // throw new Error('urlPattern should be empty, string or regular expression');
    }
    if (typeof callback !== 'function') {
        throw new Error('callback should be a function');
    }

    // console.log('Setting up listening...');
    api.executeScript(_client.clientListen);
    // console.warn('Listening XHR requests');

    var matchingXhrs = null;

    var interval = setInterval(function () {
        return api.executeScript(_client.clientPoll).then(function (xhrs) {
            // console.log('xhrss', xhrs);
            matchingXhrs = xhrs ? xhrs.filter(function (xhr) {
                return xhr.url.match(urlPattern);
            }) : null;
            if (matchingXhrs) {
                callback(matchingXhrs);
                clearInterval(interval);
                clearTimeout(timeout);
            }
        });
    }, 300);
    var timeout = setTimeout(function () {
        clearInterval(interval);
        if (matchingXhrs) callback(matchingXhrs);else throw new Error('Request never ocurred');
    }, delay);

    // console.log('Done');
    return this;
}

function waitForNextXHR(urlPattern, time) {
    return new Promise(function (resolve, reject) {
        try {
            waitForNextXHRWithCB(urlPattern, time, function (xhrs) {
                resolve(xhrs);
            });
        } catch (e) {
            reject(e);
        }
    });
}